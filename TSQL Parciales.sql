/*Implementar una regla de negocio que registre en una tabla llamadaSEC, cuyos campos son : id, fecha_hora, tipo, sucurusal, numero, lainformación de aquellas operaciones que intentan borrar una factura y/osus items.*/CREATE TABLE SEC( sec_id int identity(1,1), sec_fecha_hora smalldatetime, sec_tipo char(1), sec_sucursal char(4), sec_numero char(8))GOCREATE TRIGGER regla_negocio_fact ON Factura INSTEAD OF deleteASBEGIN	DECLARE @fact_fecha smalldatetime, @tipo char(1), @sucursal char(4), @numero char(8)	DECLARE curDeletedFactura CURSOR for (SELECT d.fact_fecha, d.fact_tipo, d.fact_sucursal, d.fact_numero FROM deleted d)	OPEN curDeletedFactura	FETCH NEXT FROM curDeletedFactura INTO @fact_fecha, @tipo, @sucursal, @numero	WHILE @@FETCH_STATUS = 0	BEGIN		INSERT INTO SEC (sec_fecha_hora, sec_tipo, sec_sucursal, sec_numero)		SELECT d.fact_fecha, d.fact_tipo, d.fact_sucursal, d.fact_numero		FROM deleted d		WHERE d.fact_fecha+d.fact_tipo+d.fact_sucursal+d.fact_numero = @fact_fecha+@tipo+@sucursal+@numero		FETCH NEXT FROM curDeletedFactura INTO @fact_fecha, @fact_tipo, @fact_sucursal, @fact_numero	END	CLOSE curDeletedFactura	DEALLOCATE curDeletedFacturaENDGOCREATE TRIGGER regla_negocio_item ON Item_Factura INSTEAD OF deleteASBEGIN	DECLARE @fact_fecha smalldatetime, @tipo char(1), @sucursal char(4), @numero char(8)	DECLARE curDeletedFactura CURSOR for (SELECT fact_fecha, fact_tipo, fact_sucursal, fact_numero										  FROM deleted d											 JOIN Factura on fact_tipo+fact_sucursal+fact_numero = d.item_tipo+d.item_sucursal+d.item_numero)	OPEN curDeletedFactura	FETCH NEXT FROM curDeletedFactura INTO @fact_fecha, @tipo, @sucursal, @numero	WHILE @@FETCH_STATUS = 0	BEGIN		INSERT INTO SEC (sec_fecha_hora, sec_tipo, sec_sucursal, sec_numero)		SELECT fact_fecha, fact_tipo, fact_sucursal, fact_numero		FROM deleted d			JOIN Factura on fact_tipo+fact_sucursal+fact_numero = d.item_tipo+d.item_sucursal+d.item_numero		WHERE fact_fecha+fact_tipo+fact_sucursal+fact_numero = @fact_fecha+@tipo+@sucursal+@numero		FETCH NEXT FROM curDeletedFactura INTO @fact_fecha, @fact_tipo, @fact_sucursal, @fact_numero	END	CLOSE curDeletedFactura	DEALLOCATE curDeletedFacturaENDGO/*Implementar una regla de negocio en línea donde se valide que nuncaun producto compuesto pueda estar compuesto por componentes derubros distintos a el*/CREATE TRIGGER dbo.tsql2 ON Composicion AFTER insert, updateASBEGIN	DECLARE @rubro_producto char(4), @rubro_componente char(4)	DECLARE curInserted CURSOR for (select p1.prod_rubro, p2.prod_rubro  									from inserted i										join Producto p1 on p1.prod_codigo = i.comp_producto										join Producto p2 on p2.prod_codigo = i.comp_componente)	OPEN curInserted	FETCH NEXT FROM curInserted INTO @rubro_producto, @rubro_componente	WHILE @@FETCH_STATUS = 0	BEGIN		IF(@rubro_producto != @rubro_componente)		BEGIN			ROLLBACK TRANSACTION			print 'Un producto no puede estar compuesto por componentes de rubros distintos a el'		END		FETCH NEXT FROM curInserted INTO @rubro_producto, @rubro_componente	END	CLOSE curInserted	DEALLOCATE curInsertedENDGO/*Implementar el/los objetos necesarios para que cada vez que se genere unan venta,si existe un producto compuesto, descuente del STOCK los componentes.*/CREATE TRIGGER descontarStockComponentes ON Item_Factura AFTER insertASBEGIN	DECLARE @componente char(8), @cantComponente decimal(12,2)	DECLARE curProdCompuesto CURSOR for (select c1.comp_componente, i.item_cantidad * c1.comp_cantidad										 from inserted i											inner join Composicion c1 on i.item_producto = c1.comp_producto)	OPEN curProdCompuesto	FETCH NEXT FROM curProdCompuesto INTO @componente, @cantComponente	WHILE @@FETCH_STATUS = 0	BEGIN		UPDATE STOCK		SET stoc_cantidad -= @cantComponente		WHERE stoc_producto = @componente and stoc_cantidad >= @cantComponente		FETCH NEXT FROM curProdCompuesto INTO @componente, @cantComponente	END	CLOSE curProdCompuesto	DEALLOCATE curProdCompuestoENDGO/*2. Suponiendo que se aplican los siguientes cambios en el modelo de
datos:
Cambio 1) create table provincia (id int primary key, nombre char(100)) ;
Cambio 2) alter table cliente add pcia_id int null;
Crear el/los objetos necesarios para implementar el concepto de foreign
key entre 2 cliente y provincia.
Nota: No se permite agregar una constraint de tipo FOREIGN KEY entre la
tabla y el campo agregado.*/CREATE TABLE Provincia(	prov_id int,	prov_nombre char(100))GOALTER TABLE Cliente ADD prov_id int nullGO--FK: Atributo de una tabla que es PK de otra/*Realizar los objetos de la base de datos necesarios para que dado un código de producto y una fecha y devuelva la mayor cantidad de días consecutivos a partir de esa fecha que elproducto tuvo al menos la venta de una unidad en el día, el sistema de ventas online estáhabilitado 24-7 por lo que se deben evaluar todos los días incluyendo domingos y feriados.*/CREATE FUNCTION parcialTSQL(@producto char(8), @fecha smalldatetime)RETURNS intBEGIN	DECLARE @contadorDias int, @contadorDiasMax int, @fechaActual smalldatetime		SET @contadorDias = 1		SET @contadorDiasMax = 1	DECLARE curFechasVentas CURSOR for (select fact_fecha										from Item_Factura											join Factura on fact_tipo+fact_sucursal+fact_numero = item_tipo+item_sucursal+item_numero										where item_producto = @producto)	OPEN curFechasVentas	FETCH NEXT FROM curFechasVentas INTO @fechaActual	WHILE @@FETCH_STATUS = 0	BEGIN		FETCH NEXT FROM curFechasVentas INTO @fechaActual	END	return 0ENDGO/*2 - 3 - 4 - 7 - 8 - 10 - 11 - 12 - 13*/